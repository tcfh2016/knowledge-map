# 第1章 欢迎进入软件构建的世界 / Welcome to Software Construction

## 1.1 什么是软件构建 / What Is Software Construction

- 构建活动主要是编码和调试，但也涉及详细设计、规划构建、单元测试、集成、集成测试等其他活
动。本书是一本关于软件构建技术的手册，它会重点关注构建活动以及与之相关的话题。
- 构建有时也被认为是“编码”或“编程”。编码算不上是最贴切的词，因为它有一种“把已经存在的设
计机械化地翻译成计算机语言”的意味；而构建并不都是这么机械化的，需要可观的创造力和判断力。
在全书中，也常常用“编程”代替“构建”。
- 一些重要的非构建活动包括管理、需求分析、软件架构设计、用户界面设计、系统测试，以及维护。
以上每一项活动都像构建活动一样最终影响着项目的成败——至少能够影响任何有不止一两个人参与、
超过几周时间才能完成的项目的成败。

## 1.2 软件构建为何如此重要 / Why Is Software Construction Important

- 构建活动是软件开发的主要组成部分。
- 构建活动是软件开发中的核心活动。
- 把主要精力集中于构建活动，可以大大提高程序员的生产率。
- 构建活动的产物——源代码——往往是对软件的唯一精确描述。
- 构建活动是唯一一项确保会完成的工作。

## 1.3 如何阅读本书 / How to Read This Book

# 第2章 用隐喻来更充分地理解软件开发 / Metaphors for a Richer Understanding of Software Development

## 2.1 隐喻的重要性 / The Importance of Metaphors

- 重要的研发成果常常产自类比（analogy）。通过把你不太理解的东西和一些你较为理解、且十分
类似的东西做比较，你可以对这些不太理解的东西产生更深刻的理解。这种使用隐喻的方法叫做“建模”。
- 模型的威力就在于其生动性，让你能够把握整个概念。它能隐隐地暗示各种属性（properties）、
关系（relationships）以及需要补充查证的部分（additional area of inquiry）。不过有时候，
当隐喻的概念被过度引申时，模型也会误导人们。
- 相对于其他学科而言，软件开发还是一门很年轻的学科，它还没有成熟到拥有一套标准隐喻的程度。
因此必然存在许多或相互补充、或相互抵触的隐喻。某些隐喻相对好一些，而另一些则比较糟糕。你
对隐喻有多理解，也就决定了你对软件开发有多理解。

## 2.2 如何使用软件隐喻 / How to Use Software Metaphors

- 对于编程来说，最大的挑战还是将问题概念化(conceptualizing)，编程中的很多错误都是概念性
的错误。正因为每一个问题在概念上都是独特的，所以要找到一套能解决所有问题的一通百通的指导
规则是很难的、甚至是不太可能的。如此看来，能一般性地知道大致如何解决问题，至少也和知道如
何解决特定问题一样有价值了。

## 2.3 常见的软件隐喻 / Common Software Metaphors

- 典型的软件系统在其首次发布之后的工作量，可能达到整个工作量的90%，典型情况下也有三分之
二之多。对写作而言，最重要的是其原创性。但是对于软件构建来说，“努力创造真正的原创成果”的
开发效率，往往低于专注于重用以往项目的一些设计思想、代码以及测试用例的开发效率。总之，写
作这一隐喻所暗示的软件开发过程太过简单、太过呆板了。
- 通过把软件的构建过程比作是房屋的建设过程，我们可以发现，仔细的准备是必要的，而大型项目
和小型项目之间也是有差异的。
- 通过把软件开发中的实践比作是智慧工具箱中的工具，我们又发现，每位程序员都有许多工具，但
并不存在任何一个能适用于所有工作的工具，因地制宜地选择正确工具是成为能有效编程的程序员的
关键。

# 第3章 三思而后行：前期准备 / Measure Twice, Cut Once: Upstream Prerequisites

本章描述软件构建必须做的准备工作。就像修建建筑物一样，项目的成败很大程度上在构建活动开始
之前就已经注定了。如果地基没打好，或者计划不充分，那么你在构建期间能做的无非是尽量让损害
最小罢了。

## 3.1 前期准备的重要性 / Importance of Prerequisites

- 在软件开发中，如果需求被污染了，那么它就会污染架构，而架构又会污染构建。这样会导致程序
员脾气暴躁、营养失调；开发出的软件具有放射性污染，而且周身都是缺陷。
- 惠普、IBM、休斯飞机公司、TRW以及其他组织的研究人员发现，在构建活动开始之前清除一个错误，
那么返工的成本仅仅是“在开发过程的最后阶段（在系统测试期间或者发布之后）做同样事情” 的十分
之一到百分之一。
- 一般而言，这里的原则是：发现错误的时间要尽可能接近引入该错误的时间。缺陷在软件食物链里
面呆的时间越长，它对食物链的后级造成损害就越严重。由于需求是首先要完成的事情，需求的缺陷
就有可能在系统中潜伏更长的时间，代价也更加昂贵。在软件开发过程的上游引入的缺陷通常比那些
在下游引入的缺陷具有更广泛的影响力。这也使得早期的缺陷代价更加高昂。

## 3.2 辨明你所从事的软件的类型 / Determine the Kind of Software You're Working On

- 有些作者断言，使用迭代技术的项目基本无须关注前期准备，但这种观点是错的。迭代方法往往能
够减少前期准备不足造成的负面影响，但是它不能完全消除此影响。
- 无论你使用的是迭代式开发法还是序列式开发法，只要进行前期准备，就可以减少成本。迭代式开
发法通常是更好的选择这一观点有很多的理由支持。但是忽略前期准备的迭代式开发法，最终明显会
比密切关注前期准备工作的序列式开发法付出更高的代价。

## 3.3 问题定义的先决条件 / Problem-Definition Prerequisite

- "问题定义"只定义了“问题是什么”，而不涉及任何可能的解决方案。它是一个很简单的陈述，可能
只有一到两页，并且听起来应该像是一个问题。
- 问题定义应该用客户的语言来书写，而且应该从客户的角度来描述问题。通常不应该用计算机的专
业术语叙述，如果需要解决的是计算机本身相关的问题则例外。
- “未能定义问题”的处罚是，你浪费了大量时间去解决错误的问题。这是双重处罚，因为你也没有解
决正确的问题。

## 3.4 需求的先决条件 / Requirements Prerequisite

- 明确的需求有助于确保用户（而不是程序员）驾驭系统的功能。如果需求明确，那么用户就可以自
行评审，并进行核准。否则，程序员就常常会在编程期间自行决定需求。明确的需求免得你去猜测用
户想要的是什么。
- “一旦客户接受了一份需求文档，就再也不做更改”是一个美好的愿望。然而，对一个典型的项目来
说，在编写代码之前，客户无法可靠地描述他们想要的是什么。问题并不在于客户是低级生物。就如
同你做这个项目的时间越长，对这个项目的理解也就越深入一样，客户参与项目的时间越长，他们对
项目的理解也就越深入。开发过程能够帮助客户更好地理解自己的需求，这是需求变更的主要来源。
计划严格依照需求行事，实际上就是计划不对客户的要求做出回应。

## 3.5 架构的先决条件 / Architecture Prerequisite

- 错误处理已被证实为现代计算机科学中最棘手的问题之一，你不能武断地处理它。有人估计程序中
高达90%的代码是用来处理异常情况、进行错误处理、或做簿记工作，意味着只有10%的代码是用来处
理常规的情况。既然这么多代码致力于处理错误，那么在架构中就应该清楚地说明一种“一致地处理错
误”的策略。
- 优秀的架构规格书的特点在于，讨论了系统中的类、讨论了每个类背后的隐藏信息、讨论了“采纳
或排斥所有可能的设计替代方案”的根本理由。
- 架构应该描述所有主要决策的动机。谨防“我们向来这么做”这种自认为有理的说法。
- 你不应该担忧架构的任何部分。架构不应该包含任何仅仅为了取悦老板的东西。它不应该包含任何
对你而言很难理解的东西。你就是那个实现架构的人：如果你自己都弄不懂，那怎么实现它？

## 3.6 花费在前期准备上的时间长度 / Amount of Time to Spend on Upstream Prerequisites

- 花费在问题定义、需求分析、软件架构上的时间，依据项目的需要而变化。一般说来，一个运作良
好的项目会在需求、架构以及其他前期计划方面投入10%~20%的工作量和20%~30%的时间。这些数字
不包括详细设计的时间——那是构建活动的一部分。

# 第4章 关键的“构建”决策 / Key Construction Decisions

## 4.1 选择编程语言 / Choice of Programming Language

- 使用高级语言的程序员能比使用较低级的语言的程序员达到更好的生产率和质量。另外，高级语言
比低级语言的表达力更强。每行代码能表达更多的含义。

## 4.2 编程约定 / Programming Conventions

- 成功编程的一个关键就在于避免随意地变化，这样你的大脑可以专注于那些真正需要的变化。

## 4.3 你在技术浪潮中的位置 / Your Location on the Technology Wave

- 正如 David Geries所言，编程工具不应该决定你的编程思路。
- “深入一种语言去编程”的程序员首先决定他要表达的思想是什么，然后决定如何使用特定语言提供
的工具来表达这些思想。

## 4.4 选择主要的构建实践方法 / Selection of Major Construction Practices
