# 聚宽学习第六周周记：基金的净值概念和选取处于历史地位的ETF基金

春节期间一直关注疫情，心思波动比较大。到这周开始在家办公才逐步将心思收回了一些，但在聚宽上的学习还在逐步进入状态。本周的周记是重新对之前的代码笔记的详细解释，有关定投前期基金的选择。

## 一、`获取处于历史地位的ETF基金`代码解释

原版代码见[价值研究笔记之获取处于历史地位TOP10的ETF基金](https://www.joinquant.com/view/community/detail/b7f2d084d39662b0b21295fe4db25211)。在这之前必须要先弄清楚与评价基金收益的两个基本概念：“基金单位净值”和“基金累积净值”，因为这两个概念花了我好几个小时的时间去弄清楚。

基金的单位净值表示1份额基金在当前时间点的净值，也就是当前的交易价格，它可以随着基金的拆分/合并而变更。比如，基金A共募集1万元，共计1万份，即单位净值为1元。一年后，基金A通过基金经理艰苦卓越的投资后盈利2000元，此时每份净值变更为1.2元。如果年末该基金将2000元的盈利全部派现给持有者，那么持有者共收到2000元的现金，而基金的单位净值重新回归到1元。

基金的单位净值只会体现当前基金的净值，不会体现以往已有的分红。所以我们有了基金的累计净值，它包括了基金上市以来的盈利。比如，基金A共募集1万元，共计1万份，即单位净值为1元，累积净值此时等于单位净值也为1元。一年后，基金A通过基金经理艰苦卓越的投资后盈利2000元，此时每份净值变更为1.2元。年末该基金将2000元的盈利全部派现给持有者，持有者共收到2000元的现金，而基金的单位净值重新回归到1元，但累计净值依然为1.2元。

我们可以用“累计净值 = 单位净值 + 历史上每单位基金分红”来体现“累计净值”和“单位净值”之间的关系，这么看起来“累计净值”是一定大于“单位净值”的。最让人费解的地方来了，因为我在获取基金累计净值的时候发现了有的时候基金的累计净值可能小于单位净值，比如[关于中证500交易型开放式指数证券投资基金份额折算结果及恢复交易和申购赎回公告](http://static.cninfo.com.cn/finalpage/2015-04-15/1200835798.PDF)有关于基金折算的如下描述：

>权益登记日当日，中证500指数收盘值为8122.893点，本基金资产净值为6,753,939,734.31元，折算前基金份额总额为2,966,093,841份。根据基金份额折算公式，基金份额折算比例为0.28032483，折算后基金份额总额为831,467,244份，折算后基金份额净值为8.1198元，基金份额累计净值为2.2762元。

要明白这里面的过程需要理解如下几点：

- 基金在运作过程中可能涉及到份额的折算、合并和拆分等操作。折算通常是将基金的单位净值折算到对应跟踪指数的千分之一，而合并和拆分类似于股票的转增股票股息，带有一定的营销手法，可以从公告里面查阅具体原因。
- 基金在折算、合并和拆分的时候直接收影响的是单位净值，而累计净值往往不会收到影响。通俗点理解就是，基金的单位净值会受到当前最新基金份额的变动而变动，但基金的累计净值通常以最初的基金份额为基数，不会随着折算/合并/拆分之后新的基金份额而变动。

比如，[关于中证500交易型开放式指数证券投资基金实施基金份额折算及相关业务安排的第五次提示性公告](http://static.cninfo.com.cn/finalpage/2015-04-13/1200822718.PDF)里提到基金份额折算后基金份额累计净值＝（基金份额净值＋基金折算后的份额分红金额）×基金份额折算比例。从这个公式里面可以理解基金折算后的累计净值不会有大的变化，但是单位净值变化会很大。比如折算前单位净值为1.0元的1000份，按照1/2折算为500份，每份单位净值变更为2.0元，但累计净值依然为（2.0 + 分红）/2，假设分红为0，仍旧为1元。

理解了“基金单位净值”和“基金累积净值”的区别之后对于我们使用聚宽获取基金净值时就能够更加明确使用哪些数据来计算我们想要的数据了。下面的代码使用的核心变量就“累积净值”，通过获取、比较各个ETF基金的累计净值来找到从历史角度来看当前仍旧处于地位的ETF基金，如下是代码解释部分。

```
all_funds_df = get_all_securities(['fund'])
etf_funds_df = all_funds_df[all_funds_df['type'] == 'etf']

trade_days = get_trade_days('2014-01-01', '2019-12-27')
start = trade_days[0]
end = trade_days[-1]
df = etf_funds_df[(etf_funds_df['start_date'] < start) & (etf_funds_df['end_date'] > end)]

acc_value_df = get_extras('acc_net_value', df.index, start_date=start, end_date=end, df=True)
curr_div_max = acc_value_df.loc[end] / acc_value_df.describe().loc['max']

top10_fund_code = curr_div_max.sort_values(ascending=True).index[0:10]
print(top10_fund_code)
top10_fund_name = [get_security_info(stock_code).display_name for stock_code in top10_fund_code]
print(top10_fund_name)
```

获取的结果如下：

```
Index(['159918.XSHE', '159930.XSHE', '159932.XSHE', '159915.XSHE',
       '510510.XSHG', '510440.XSHG', '159922.XSHE', '510500.XSHG',
       '510410.XSHG', '159907.XSHE'],
      dtype='object')
['中创400', '能源ETF', '500深ETF', '创业板', '广发500', '500沪市', '500ETF', '500ETF', '资源ETF', '中小300']
```

**代码片段一：**

```
all_funds_df = get_all_securities(['fund'])
etf_funds_df = all_funds_df[all_funds_df['type'] == 'etf']
```

`get_all_securities()`这个函数我们已经使用好多次了，只不过之前都没有使用`fund`这个函数参数。可以在[get_all_securities - 获取所有标的信息](https://www.joinquant.com/help/api/help?name=JQData#get_all_securities-%E8%8E%B7%E5%8F%96%E6%89%80%E6%9C%89%E6%A0%87%E7%9A%84%E4%BF%A1%E6%81%AF)里面查看它的具体用法，如果不给它传入参数它默认返回聚宽平台支持的所有股票，我们使用的时候传入了`fund`这个参数，表明我们要获取聚宽上的所有基金数据，打印出来的结果如下：

```
               display_name      name  start_date    end_date type
150008.XSHE         瑞和小康      RHXK  2009-11-19  2200-01-01  fja
150009.XSHE         瑞和远见      RHYJ  2009-11-19  2200-01-01  fjb
150012.XSHE         中证100A    ZZ100A  2010-06-18  2200-01-01  fja
150013.XSHE         中证100B    ZZ100B  2010-06-18  2200-01-01  fjb
150016.XSHE          合润A       HRA  2010-05-31  2200-01-01  fja
150017.XSHE          合润B       HRB  2010-05-31  2200-01-01  fjb
150018.XSHE         银华稳进      YHWJ  2010-06-07  2200-01-01  fja
150019.XSHE         银华锐进      YHRJ  2010-06-07  2200-01-01  fjb
150022.XSHE         深成指A      SCZA  2010-11-08  2200-01-01  fja
......
```

然后我们使用`all_funds_df[all_funds_df['type'] == 'etf']`从中筛选出所有的etf基金，结果如下：

```
               display_name      name  start_date    end_date type
159001.XSHE          保证金       BZJ  2014-10-20  2200-01-01  etf
159003.XSHE         招商快线      ZSKX  2014-10-20  2200-01-01  etf
159005.XSHE         添富快钱      TFKQ  2015-01-13  2200-01-01  etf
159901.XSHE         深100ETF   S100ETF  2006-04-24  2200-01-01  etf
159902.XSHE          中小板       ZXB  2006-09-05  2200-01-01  etf
159903.XSHE         深成ETF     SCETF  2010-02-02  2200-01-01  etf
......
```

写到这里其实我发现这两行代码写得过于冗余了，直接用一行就搞定了：`all_funds_df = get_all_securities(['etf'])`，因为前面刚提到可以直接传入`etf`参数，而不用从获取的所有基金数据里面使用type来进行过滤。

**代码片段二：**

```
trade_days = get_trade_days('2014-01-01', '2019-12-27')
start = trade_days[0]
end = trade_days[-1]
df = etf_funds_df[(etf_funds_df['start_date'] < start) & (etf_funds_df['end_date'] > end)]
```

`get_trade_days()`在[第三周的周记](https://www.joinquant.com/view/community/detail/dea963ac96739ecd008c52cba3819d0c)提到过，它是在jqdata里面定义的用来获取指定日期内的所有交易日，这个函数会自动去除起止日期和结束日期中间的非交易日。如果要使用这个函数，需要在源代码文件开头加上`from jqdata import *`引入该函数的声明。

确定了日期区间之后，可以通过DataFrame特有的“布尔选择”来选中满足条件的数据，布尔选择是以某列的数据做为选择标准选出对应的行，比如要从下面的DataFrame数据里面选择start_date > 2014-01-01的那些基金，那么我们就可以使用`df[df['start_date'] > 2014-01-01]`，这种用法是Pandas里面特定的语法，要记住它。所以如上代码片段最后一句代码表示选择出那些在start日期之后发行，并且当前依然在运作的基金。

```
               display_name      name  start_date    end_date type
159901.XSHE        深100ETF   S100ETF  2006-04-24  2200-01-01  etf
159902.XSHE          中小板       ZXB  2006-09-05  2200-01-01  etf
159903.XSHE         深成ETF     SCETF  2010-02-02  2200-01-01  etf
159905.XSHE          深红利       SHL  2011-01-11  2200-01-01  etf
159906.XSHE          深成长       SCZ  2011-02-23  2200-01-01  etf
159907.XSHE         中小300     ZX300  2011-08-10  2200-01-01  etf
159908.XSHE         博时创业     SF200  2011-07-13  2200-01-01  etf
......
```

**代码片段三：**

```
acc_value_df = get_extras('acc_net_value', df.index, start_date=start, end_date=end, df=True)
curr_div_max = acc_value_df.loc[end] / acc_value_df.describe().loc['max']
```

`get_extras()`是个新函数，可以在[get_extras - 获取基金净值/期货结算价等](https://www.joinquant.com/help/api/help?name=JQData#get_extras-%E8%8E%B7%E5%8F%96%E5%9F%BA%E9%87%91%E5%87%80%E5%80%BC%E6%9C%9F%E8%B4%A7%E7%BB%93%E7%AE%97%E4%BB%B7%E7%AD%89)里查找到它的详细用法，它可以用来获取基金和期货的数据，但我们这里仅仅用来获取基金的净值数据。

使用这个函数的时候传入`acc_net_value`获取到的是基金累计净值，而参数`unit_net_value`对应的是单位净值。由于我们在开头已经详细介绍了基金单位净值和累计净值的区别，我们这里只需要使用“累计净值”。

代码的第1行是获取所有基金在[start, end]这段时期的累计净值，`df.index`是如上DataFrame数据表的索引，包含了所有的etf基金的代码。获取的结果为DataFrame类型，即二维表数据类型，index为日期，column为基金代码：

```
            159901.XSHE  159902.XSHE     ...       518800.XSHG  518880.XSHG
2014-01-02       2.7891        2.482     ...            0.9109       0.9140
2014-01-03       2.7701        2.487     ...            0.9165       0.9190
2014-01-06       2.6994        2.431     ...            0.9224       0.9260
2014-01-07       2.6994        2.450     ...            0.9239       0.9270
2014-01-08       2.7065        2.464     ...            0.9095       0.9130
2014-01-09       2.6790        2.429     ...            0.9090       0.9120
2014-01-10       2.6443        2.389     ...            0.9134       0.9170
2014-01-13       2.6196        2.375     ...            0.9265       0.9300
2014-01-14       2.6557        2.410     ...            0.9259       0.9290
......
```

第2行代码完成的计算是将每个基金“累计净值的当前值”和“历史累计净值的最大值”相除，作为衡量未来涨幅空间的判断指标，比如有两只ETF基金A和B，A当前的累计净值为2.0，历史的最高累计净值为8.0，B当前的累计净值为1.5，历史的最高累计净值为5.0，那么对于A的计算值为 2.0/8.0 = 0.25，B的计算值为 1.5/5.0 = 0.3。那么，当前的算法认为A当前相比B处于低位。

**代码片段四：**

```
top10_fund_code = curr_div_max.sort_values(ascending=True).index[0:10]
print(top10_fund_code)
top10_fund_name = [get_security_info(stock_code).display_name for stock_code in top10_fund_code]
print(top10_fund_name)
```

我们最后将计算好的各个基金对应的值按照从小到大排序并且选取排名前10的基金并打印出来，同时打印出这些基金对应的中文名称。

## 二、下周计划任务

### 1.什么是网格交易？

宽友@odbo有一次提到“网格交易”这个名词，自己还没有了解过，做些学习和了解。

### 2.修改之前第一个模拟定投的策略，计算下真实收益率
