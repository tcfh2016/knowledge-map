## 第6章 可以工作的类

在计算时代的早期，程序员基于语句思考编程问题。到了20世纪七八十年代，程序员开始基于子程序去思考编程。进入21世纪，程序员以类为基础思考编程问题。

类是由一组数据和子程序构成的集合，这些数据和子程序共同拥有一组内聚的、明确定义的职责。类也可以只是由一组子程序构成的集合，这些子程序提供一组内聚的服务，哪怕其中并未涉及共用的数据。成为高效程序员的一个关键就在于，在当开发程序任一部分的代码时，都能安全地忽视程序中尽可能多的其余部分。而类就是实现这一目标的首要工具。


### 6.1 类的基础：抽象数据类型（ADTs）

抽象数据类型（ADT, abstract data type）是指一些数据以及对这些数据所进行的操作的集合。要想理解面向对象编程，首先要理解ADT。不懂ADT的程序员开发出来的类只是名义上的“类”而已——实际上这种“类”只不过就是把一些稍有点儿关系的数据和子程序堆在一起。然而在理解ADT之后，程序员就能写出在一开始很容易实现、日后也易于修改的类来。

*首先考虑ADT，而后猜考虑类。*

使用ADT的好处：

- 可以隐藏实现细节。
- 改动不会影响到整个程序。
- 让接口能提供更多信息。
- 更容易提高性能。
- 程序更具自我说明性。
- 无须在程序内到处传递数据。
- 可以想象在现实世界中那样操作实体，而不用在底层实现上操作它。


### 6.2 良好的类接口

创建高质量的类，第一步，可能也是最重要的一步，就是创建一个好的接口。这也包括了创建一个可以通过接口来展现的合理的抽象，并确保细节仍被隐藏在抽象背后。

**好的抽象**

抽象是一种以简化的形式来看待复杂操作的能力。类的接口为隐藏在其后的具体实现提供了一种抽象。类的接口应能提供一组明显相关的子程序。

为了追求设计优秀，这里给出一些创建类的抽象接口的指导建议：

- 类的接口应该展现一致的抽象层次：在考虑类的时候有一种很好的方法，就是把类看做一种用来实现抽象数据类型（ADT）的机制。每一个类应该实现一个ADT，并且仅实现这个ADT。如果你发现某个类实现了不止一个ADT，或者你不确定究竟它实现了何种ADT，你就应该把这个类重新组织为一个或多个定义更加明确的ADT。
- 一定要理解类所实现的抽象是什么：一些类非常相像，你必须非常仔细地理解类的接口应该捕捉的抽象到底是哪一个。
- 提供成对的服务：大多数操作都有和其相应的、相等的以及相反的操作。在设计一个类的时候，要检查每一个公用子程序，决定是否需要另一个与其互补的操作。不要盲目地创建相反操作，但你一定要考虑，看看是否需要它。
- 把不相关的信息转移到其他类中：有时你会发现，某个类中一半子程序使用着该类的一半数据，而另一半子程序则使用另一半数据。这时你其实已经把两个类混在一起使用了，把它们拆开吧！
- 尽可能让接口可编程，而不是表达语义。每个接口都由一个可编程（programmatic）的部分和一个语义（semantic）部分组成。可编程的部分由接口中的数据类型和其他属性构成，编译器能强制性地要求它们。而语义部分则由“本接口将会被怎样使用”的假定组成，而这些是无法通过编译器来强制实施的。一个接口中任何无法通过编译器强制实施的部分，就是一个可能被误用的部分。要想办法把语义接口的元素转换为编程接口的元素，比如说用Asserts或其他的技术。
- 谨防在修改时破坏接口的抽象：在对类进行修改和扩展的过程中，你常常会发现额外所需的一些功能。这些功能并不十分适用于原有的类接口。
- 不要添加与接口抽象不一致的公用成员：每次你向类的接口中添加子程序时，问问“这个子程序与现有接口所提供的抽象一致吗？”如果发现不一致，就要换另一种方法来进行修改，以便能够保持抽象的完整性。
- 同时考虑抽象性和内聚性：抽象性和内聚性这两个概念之间的关系非常紧密。我发现，关注类的接口所表现出来的抽象，比关注类的内聚性更有助于深入地理解类的设计。如果你发现某个类的内聚性很弱，也不知道该怎么改，那就换一种方法，问问你自己这个类是否表现为一致的抽象。

**良好的封装**

封装是一个比抽象更强的概念。抽象通过提供一个可以让你忽略实现细节的模型来管理复杂度，而封装则强制阻止你看到细节。

- 尽可能地限制类和成员的可访问性。
- 不要公开暴露成员数据。
- 避免把私用的实现细节放入类的接口中。
- 不要对类的使用者做出任何假设。
- 避免使用友元类：有些场合下，比如State模式中，按正确的方式使用友元有助于管理复杂度。但在一般情况下会破坏封装，因为它让你同一时刻需要考虑更多的代码量，从而增加了复杂度。
- 不要因为一个子程序里仅使用公用子程序，就将它归入公开接口。
- 让阅读代码比编写代码更方便。
- 要格外警惕从语义上破坏封装性。
- 留意过于紧密的耦合关系。


### 6.3 有关设计和实现的问题

给类定义合理的接口，对于创建高质量程序起到了关键作用。然而，类内部的设计和实现也同样重要。这一节就来论述关于包含、继承、成员函数和数据成员、类之间的耦合性、构造函数、值对象与引用对象等的问题。

**包含（“有一个...”的关系）**

包含是一个非常简单的概念，它表示一个类含有一个基本数据元素或对象。包含是面向对象编程中的主力技术。

- 通过包含来实现“有一个/has a”的关系。
- 在万不得已时通过private继承来实现“有一个”的关系。
- 警惕有超过约7个数据成员的类：研究表明，人们在做其他事情时能记住的离散项目个数是7（上下浮动2）。如果一个类包含有超过约7个数据成员，请考虑要不要把它分解为几个更小的类。

**继承（“是一个...”的关系）**

继承的概念是说一个类是另一个类的一种特化。继承的目的在于，通过“定义能为两个或更多个派生类提供共有元素的基类”的方式写出更精简的代码。其中的共有元素可以是子程序接口、内部实现、数据成员或数据类型等。继承能把这些共有的元素集中在一个基类中，从而有助于避免在多处出现重复的代码和数据。

- 用public继承来实现“是一个...”的关系：当程序员决定通过继承一个现有类的方式创建一个新类时，他是在表明这个新的类是现有类的一个更为特殊的版本。
- 要么使用继承并进行详细说明，要么就不要用它：继承给程序增加了复杂度，因此它是一种危险的技术。
- 遵循Liskov替换原则（Liskov Substitution Principle, LSP）：Barbara Liskov在一篇面向对象编程的开创性论文中提出，除非派生类真的“是一个”更特殊的基类，否则不应该从基类继承。Andy Hunt和Dave Thomas把LSP总结为：“派生类必须能通过基类的接口而被使用，且使用者无须了解两者之间的差异。”
- 确保只继承需要继承的部分。
- 避免让继承体系过深：依我的经验，大多数人在脑中同时应付超过2到3层继承时就有麻烦了。
- 尽量使用多态，避免大量的类型检查。
- 谨慎使用多重继承：以我的经验而言，多重继承的用途主要是定义“混合体（mixins）”，也就是一些能给对象增加一组属性的简单类。

**成员函数和数据成员**

- 让类中子程序的数量尽可能少。
- 禁止隐式地产生你不需要的成员函数和运算符：有时你会发现应该禁止某些成员函数，比如说你想禁止赋值，或不想让某个对象被构造，你完全可以通过把构造函数、赋值运算符或其他成员函数或运算符定义为private，从而禁止调用方访问它们。

**构造函数**

- 如果可能，应该在所有的构造函数中初始化所有的数据成员。
- 用private构造函数来强制实现单件属性。
- 优先采用深层复本（deep copies），除非论证可行，才采用浅层复本（shallow copies）。


### 6.4 创建类的原因

- 为现实世界的对象建模
- 为抽象的对象建模
- 降低复杂度
- 隔离复杂度
- 隐藏实现细节
- 限制变动的影响范围
- 隐藏全局数据
- 让参数传递更顺畅
- 建立中心控制点
- 让代码更易于重用

尽管通常情况下类是有用的，但在一些情况下应避免创建特定的类，比如避免创建万能类，如果一个类只包含数据但不包含行为时可以将类降级，让它的数据成员成为一个或多个其他类的属性。


### 6.6 超越类：包

类是当前程序员们实现模块化（modularity）的最佳方式。不过模块化是个很庞大的话题，其影响范围要远远超出类。在过去几十年间，软件开发的进展在很大程度上要归功于我们在编程时进行工作的粒度的增长。首先是语句，这在当时算得上是自从机器指令以来迈进的一大步。接下来就是子程序，再后来则是类。

很显然，如果我们能有更好的工具来把对象聚合起来，我们就可能更好地朝着抽象和封装的目标迈进。
