## 第3章 三思而后行：前期准备 / Measure Twice, Cut Once: Upstream Prerequisites

本章描述软件构建必须做的准备工作。就像修建建筑物一样，项目的成败很大程度上在构建活动开始
之前就已经注定了。如果地基没打好，或者计划不充分，那么你在构建期间能做的无非是尽量让损害
最小罢了。

### 3.1 前期准备的重要性 / Importance of Prerequisites

- 在软件开发中，如果需求被污染了，那么它就会污染架构，而架构又会污染构建。这样会导致程序
员脾气暴躁、营养失调；开发出的软件具有放射性污染，而且周身都是缺陷。
- 惠普、IBM、休斯飞机公司、TRW以及其他组织的研究人员发现，在构建活动开始之前清除一个错误，
那么返工的成本仅仅是“在开发过程的最后阶段（在系统测试期间或者发布之后）做同样事情” 的十分
之一到百分之一。
- 一般而言，这里的原则是：发现错误的时间要尽可能接近引入该错误的时间。缺陷在软件食物链里
面呆的时间越长，它对食物链的后级造成损害就越严重。由于需求是首先要完成的事情，需求的缺陷
就有可能在系统中潜伏更长的时间，代价也更加昂贵。在软件开发过程的上游引入的缺陷通常比那些
在下游引入的缺陷具有更广泛的影响力。这也使得早期的缺陷代价更加高昂。

### 3.2 辨明你所从事的软件的类型 / Determine the Kind of Software You're Working On

- 有些作者断言，使用迭代技术的项目基本无须关注前期准备，但这种观点是错的。迭代方法往往能
够减少前期准备不足造成的负面影响，但是它不能完全消除此影响。
- 无论你使用的是迭代式开发法还是序列式开发法，只要进行前期准备，就可以减少成本。迭代式开
发法通常是更好的选择这一观点有很多的理由支持。但是忽略前期准备的迭代式开发法，最终明显会
比密切关注前期准备工作的序列式开发法付出更高的代价。

### 3.3 问题定义的先决条件 / Problem-Definition Prerequisite

- "问题定义"只定义了“问题是什么”，而不涉及任何可能的解决方案。它是一个很简单的陈述，可能
只有一到两页，并且听起来应该像是一个问题。
- 问题定义应该用客户的语言来书写，而且应该从客户的角度来描述问题。通常不应该用计算机的专
业术语叙述，如果需要解决的是计算机本身相关的问题则例外。
- “未能定义问题”的处罚是，你浪费了大量时间去解决错误的问题。这是双重处罚，因为你也没有解
决正确的问题。

### 3.4 需求的先决条件 / Requirements Prerequisite

- 明确的需求有助于确保用户（而不是程序员）驾驭系统的功能。如果需求明确，那么用户就可以自
行评审，并进行核准。否则，程序员就常常会在编程期间自行决定需求。明确的需求免得你去猜测用
户想要的是什么。
- “一旦客户接受了一份需求文档，就再也不做更改”是一个美好的愿望。然而，对一个典型的项目来
说，在编写代码之前，客户无法可靠地描述他们想要的是什么。问题并不在于客户是低级生物。就如
同你做这个项目的时间越长，对这个项目的理解也就越深入一样，客户参与项目的时间越长，他们对
项目的理解也就越深入。开发过程能够帮助客户更好地理解自己的需求，这是需求变更的主要来源。
计划严格依照需求行事，实际上就是计划不对客户的要求做出回应。

### 3.5 架构的先决条件 / Architecture Prerequisite

- 错误处理已被证实为现代计算机科学中最棘手的问题之一，你不能武断地处理它。有人估计程序中
高达90%的代码是用来处理异常情况、进行错误处理、或做簿记工作，意味着只有10%的代码是用来处
理常规的情况。既然这么多代码致力于处理错误，那么在架构中就应该清楚地说明一种“一致地处理错
误”的策略。
- 优秀的架构规格书的特点在于，讨论了系统中的类、讨论了每个类背后的隐藏信息、讨论了“采纳
或排斥所有可能的设计替代方案”的根本理由。
- 架构应该描述所有主要决策的动机。谨防“我们向来这么做”这种自认为有理的说法。
- 你不应该担忧架构的任何部分。架构不应该包含任何仅仅为了取悦老板的东西。它不应该包含任何
对你而言很难理解的东西。你就是那个实现架构的人：如果你自己都弄不懂，那怎么实现它？

### 3.6 花费在前期准备上的时间长度 / Amount of Time to Spend on Upstream Prerequisites

- 花费在问题定义、需求分析、软件架构上的时间，依据项目的需要而变化。一般说来，一个运作良
好的项目会在需求、架构以及其他前期计划方面投入10%~20%的工作量和20%~30%的时间。这些数字
不包括详细设计的时间——那是构建活动的一部分。
