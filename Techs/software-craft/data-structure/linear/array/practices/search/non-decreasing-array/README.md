## 非递减数列

给你一个长度为 n 的整数数组，请你判断在 最多 改变 1 个元素的情况下，该数组能否变成一个非递减数列。

我们是这样定义一个非递减数列的： 对于数组中任意的 i (0 <= i <= n-2)，总满足 nums[i] <= nums[i + 1]。

## 解法

根据题目的意思，这个数组肯定是无序的，或者可能是递减数列。需要解决的问题是判断最多改变1个元素的情况下是否能变成非递减序列。这里理解题意容易产生误解：我第一次误解是怎样利用“1个元素”来完成顺序的变化过程，但实际上它指的是“改变”某个元素的值，所以也就是遍历一下看能否找出找过了1个的递减子数列（还需要特别的处理）。*一定要看示例*

针对“[3,4,2,3]”和“[3,4,3,3]”的特别处理：修改第二个还是第三个元素？

```
bool checkPossibility(vector<int>& nums) {
    auto cnt = 0;        
    for (size_t i = 0; i < nums.size() - 1; ++i) {
        if (nums[i] > nums[i + 1]) {
            if (++cnt > 1) {
                return false;
            }
            if (i >= 1 and nums[i + 1] < nums[i - 1]) {
                nums[i + 1] = nums[i];
            }
        }
    }
    return true;
}
```
