## 继承带来的问题

继承的复用特性很受欢迎，也经常被采用。但继承所带来的问题是无法很好地控制对其修改所带来的影响，比如下面的设计：

![](0_basical_inheritance.png)

当我们需要为`Duck`新增特性的时候必须顾及到它对所有子类所造成的影响，当给 `Duck`新增行的为不适合某一子类的时候就会出现问题，什么问题呢？主要有两种：一、子类中的需求改变，那么必须要修改子类的具体实现，也就是原有的继承体系是对修改开放的。二、如果在父类中实现了默认版本，那么需要在每个子类里面逐一检查，并做出必要的修改。比如重载基类中的方法:

![](1_overloadmethod_inheritance.png)

这将意味着以后每增加新的子类必须对父类里面继承的所有方法进行完整性考虑，对于不需要与父类保持一致的方法需要重新实现。


## 使用接口

另一种可行的方法是将这些多样化的方法剥离成“接口”，强制需要此类方法的每个子类实现自身的版本：

![](2_extractinterface_inheritance.png)

这种方法看似灵活性很大，却可能引入另一个新的问题：`MallardDuck`和`RedheadDuck`实现的`fly()`存在着一定重复性。看到继承在扩展性上面带来的这些挑战，我们需要将目光从“继承”转到“组合”。

*注：使用接口面临的代码重复性问题在Java里面没有办法解决，因为Java接口不能实现代码（Java里面可以复用继承的超类里的默认实现），但这在C++里面却不是问题，因为C++支持多重继承，尽管它可能违背了继承所应该具有的"is-a"关系。这个时候我们可以采取《Effective C++》条款39的讨论的方法——“使用private继承”。*


## 从组合方式到策略模式

我们所讨论的问题是如何解决子类行为多样化的问题，前面所讨论的重载父类的实现，子类实现特定的接口都不让人满意，此时不妨试试组合的方式，组合拥有继承复用的好处，没有继承带来的包袱。

![](3_usecomponent.png)

如上所示，使用组合看起来解决了扩展性问题，需要特定行为的子类可以将特定行为组合进来就可以了。但它还不够完美：所有的子类在一开始就创建了对应的行为对象，其行为在最初便被固定了下来，一旦之后需要修改子类的行为，依然需要修改子类本身，因此这里再更进一步让所有子类使用接口来代替具体实现。

![](4_strategy_pattern.png)

由于应用了接口，因此除了能够解决子类行为多样化的需求之外我们还能够灵活的变更它们的行为，这种变更仅仅需要调用对应接口（比如`setFlyBehavior()`）即可，这既是策略模式的一种实现。

策略模式的标准定义：

> 策略模式定义了算法簇，分别封装起来，让它们之间可以互相替换，此模式让算法的变化独立于使用算法的客户。

## 参考

- Scott Meyers，《Effective C++》，电子工业出版社，条款 32：确定你的public继承塑模出is-a关系。
- Eric Freeman & Elisabeth Freeman，《Head First 设计模式》，中国电力出版社。
